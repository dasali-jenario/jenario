// Language translations
const translations = {
    en: {
        title: "Unit Converter & Scientific Tools",
        select_language: "Language:",
        category: "Measurement Category",
        length: "Length",
        mass: "Mass",
        temperature: "Temperature",
        volume: "Volume",
        area: "Area",
        speed: "Speed",
        time: "Time",
        from: "From",
        to: "To",
        enter_value: "Enter value",
        initial_message: "Convert units by entering a value above",
        history: "Conversion History",
        clear_history: "Clear History",
        reload_tooltip: "Reload this conversion",
        delete_tooltip: "Delete this conversion",
        swap_tooltip: "Swap units",
        copy_tooltip: "Copy to clipboard",
        copied_tooltip: "Copied!",
        copy_tooltip_mobile: "Tap to copy",
        currency: "Currency",
        scientific: "Scientific",
        pressure: "Pressure",
        energy: "Energy",
        power: "Power",
        loading_rates: "Loading exchange rates...",
        error_rates: "Error loading exchange rates. Please try again later.",
        last_updated: "Last updated:",
        refresh_rates: "Refresh Rates",
        torque: "Torque",
        viscosity: "Viscosity",
        force: "Force",
        frequency: "Frequency",
        angle: "Angle",
        prefix_base: "Base Unit",
        density: "Density",
        theme: "Theme",
        theme_system: "System",
        theme_light: "Light",
        theme_dark: "Dark",
        search_placeholder: "Search units or conversions...",
        no_results: "No results found",
        favorites: "Favorites",
        add_to_favorites: "Add to favorites",
        remove_from_favorites: "Remove from favorites",
        pace: "Pace"
    },
    de: {
        title: "Einheitenumrechner & Wissenschaftliche Werkzeuge",
        select_language: "Sprache:",
        category: "Messkategorie",
        length: "Länge",
        mass: "Masse",
        temperature: "Temperatur",
        volume: "Volumen",
        area: "Fläche",
        speed: "Geschwindigkeit",
        time: "Zeit",
        from: "Von",
        to: "Nach",
        enter_value: "Wert eingeben",
        initial_message: "Geben Sie oben einen Wert ein",
        history: "Umrechnungsverlauf",
        clear_history: "Verlauf löschen",
        reload_tooltip: "Diese Umrechnung neu laden",
        delete_tooltip: "Diese Umrechnung löschen",
        swap_tooltip: "Einheiten tauschen",
        copy_tooltip: "In die Zwischenablage kopieren",
        copied_tooltip: "Kopiert!",
        copy_tooltip_mobile: "Zum Kopieren tippen",
        currency: "Währung",
        scientific: "Wissenschaftlich",
        pressure: "Druck",
        energy: "Energie",
        power: "Leistung",
        loading_rates: "Lade Wechselkurse...",
        error_rates: "Fehler beim Laden der Wechselkurse. Bitte später erneut versuchen.",
        last_updated: "Zuletzt aktualisiert:",
        refresh_rates: "Aktualisieren",
        torque: "Drehmoment",
        viscosity: "Viskosität",
        force: "Kraft",
        frequency: "Frequenz",
        angle: "Winkel",
        prefix_base: "Basiseinheit",
        density: "Dichte",
        theme: "Design",
        theme_system: "System",
        theme_light: "Hell",
        theme_dark: "Dunkel",
        search_placeholder: "Einheiten oder Umrechnungen suchen...",
        no_results: "Keine Ergebnisse gefunden",
        favorites: "Favoriten",
        add_to_favorites: "Zu Favoriten hinzufügen",
        remove_from_favorites: "Aus Favoriten entfernen",
        pace: "Tempo"
    },
    fr: {
        title: "Convertisseur d'Unités & Outils Scientifiques",
        select_language: "Langue:",
        category: "Catégorie de mesure",
        length: "Longueur",
        mass: "Masse",
        temperature: "Température",
        volume: "Volume",
        area: "Surface",
        speed: "Vitesse",
        time: "Temps",
        from: "De",
        to: "Vers",
        enter_value: "Entrer une valeur",
        initial_message: "Entrez une valeur ci-dessus pour convertir",
        history: "Historique des conversions",
        clear_history: "Effacer l'historique",
        reload_tooltip: "Recharger cette conversion",
        delete_tooltip: "Supprimer cette conversion",
        swap_tooltip: "Échanger les unités",
        copy_tooltip: "Copier dans le presse-papiers",
        copied_tooltip: "Copié !",
        copy_tooltip_mobile: "Appuyez pour copier",
        currency: "Devise",
        scientific: "Scientifique",
        pressure: "Pression",
        energy: "Énergie",
        power: "Puissance",
        loading_rates: "Chargement des taux de change...",
        error_rates: "Erreur lors du chargement des taux de change. Veuillez réessayer plus tard.",
        last_updated: "Dernière mise à jour :",
        refresh_rates: "Actualiser les taux",
        torque: "Couple",
        viscosity: "Viscosité",
        force: "Force",
        frequency: "Fréquence",
        angle: "Angle",
        prefix_base: "Unité de base",
        density: "Densité",
        theme: "Thème",
        theme_system: "Système",
        theme_light: "Clair",
        theme_dark: "Sombre",
        search_placeholder: "Search units or conversions...",
        no_results: "No results found",
        favorites: "Favorites",
        add_to_favorites: "Add to favorites",
        remove_from_favorites: "Remove from favorites",
        pace: "Allure"
    },
    it: {
        title: "Convertitore di Unità & Strumenti Scientifici",
        select_language: "Lingua:",
        category: "Categoria di misura",
        length: "Lunghezza",
        mass: "Massa",
        temperature: "Temperatura",
        volume: "Volume",
        area: "Area",
        speed: "Velocità",
        time: "Tempo",
        from: "Da",
        to: "A",
        enter_value: "Inserisci un valore",
        initial_message: "Inserisci un valore sopra per convertire",
        history: "Cronologia conversioni",
        clear_history: "Cancella cronologia",
        reload_tooltip: "Ricarica questa conversione",
        delete_tooltip: "Elimina questa conversione",
        swap_tooltip: "Scambia unità",
        copy_tooltip: "Copia negli appunti",
        copied_tooltip: "Copiato!",
        copy_tooltip_mobile: "Tocca per copiare",
        currency: "Valuta",
        scientific: "Scientifico",
        pressure: "Pressione",
        energy: "Energia",
        power: "Potenza",
        loading_rates: "Caricamento dei tassi di cambio...",
        error_rates: "Errore durante il caricamento dei tassi di cambio. Per favore riprovare più tardi.",
        last_updated: "Ultimo aggiornamento:",
        refresh_rates: "Aggiorna tassi",
        torque: "Coppia",
        viscosity: "Viscosità",
        force: "Forza",
        frequency: "Frequenza",
        angle: "Angolo",
        prefix_base: "Unità base",
        density: "Densità",
        theme: "Tema",
        theme_system: "Sistema",
        theme_light: "Chiaro",
        theme_dark: "Scuro",
        search_placeholder: "Search units or conversions...",
        no_results: "No results found",
        favorites: "Favorites",
        add_to_favorites: "Add to favorites",
        remove_from_favorites: "Remove from favorites",
        pace: "Ritmo"
    },
    es: {
        title: "Convertidor de Unidades & Herramientas Científicas",
        select_language: "Idioma:",
        category: "Categoría de medida",
        length: "Longitud",
        mass: "Masa",
        temperature: "Temperatura",
        volume: "Volumen",
        area: "Área",
        speed: "Velocidad",
        time: "Tiempo",
        from: "De",
        to: "A",
        enter_value: "Introducir valor",
        initial_message: "Introduce un valor arriba para convertir",
        history: "Historial de conversiones",
        clear_history: "Borrar historial",
        reload_tooltip: "Recargar esta conversión",
        delete_tooltip: "Eliminar esta conversión",
        swap_tooltip: "Intercambiar unidades",
        copy_tooltip: "Copiar al portapapeles",
        copied_tooltip: "¡Copiado!",
        copy_tooltip_mobile: "Toca para copiar",
        currency: "Moneda",
        scientific: "Científico",
        pressure: "Presión",
        energy: "Energía",
        power: "Potencia",
        loading_rates: "Cargando tasas de cambio...",
        error_rates: "Error al cargar tasas de cambio. Por favor, inténtelo más tarde.",
        last_updated: "Última actualización:",
        refresh_rates: "Actualizar tasas",
        torque: "Torque",
        viscosity: "Viscosidad",
        force: "Fuerza",
        frequency: "Frecuencia",
        angle: "Ángulo",
        prefix_base: "Unidad base",
        density: "Densidad",
        theme: "Tema",
        theme_system: "Sistema",
        theme_light: "Claro",
        theme_dark: "Oscuro",
        search_placeholder: "Search units or conversions...",
        no_results: "No results found",
        favorites: "Favorites",
        add_to_favorites: "Add to favorites",
        remove_from_favorites: "Remove from favorites",
        pace: "Ritmo"
    }
};

// Current language
let currentLanguage = localStorage.getItem('preferredLanguage') || 'en';

// Unit conversion data
const unitData = {
    length: {
        meter: 1,
        kilometer: 1000,
        centimeter: 0.01,
        millimeter: 0.001,
        mile: 1609.34,
        yard: 0.9144,
        foot: 0.3048,
        inch: 0.0254
    },
    mass: {
        kilogram: 1,
        gram: 0.001,
        milligram: 0.000001,
        pound: 0.453592,
        ounce: 0.0283495,
        ton: 1000
    },
    temperature: {
        celsius: 'base',
        fahrenheit: 'custom',
        kelvin: 'custom'
    },
    volume: {
        liter: 1,
        milliliter: 0.001,
        cubicMeter: 1000,
        gallon: 3.78541,
        quart: 0.946353,
        pint: 0.473176,
        cup: 0.236588
    },
    area: {
        squareMeter: 1,
        squareKilometer: 1000000,
        squareMile: 2589988.11,
        squareYard: 0.836127,
        squareFoot: 0.092903,
        acre: 4046.86,
        hectare: 10000
    },
    speed: {
        meterPerSecond: 1,
        kilometerPerHour: 0.277778,
        milePerHour: 0.44704,
        knot: 0.514444
    },
    time: {
        second: 1,
        minute: 60,
        hour: 3600,
        day: 86400,
        week: 604800,
        month: 2629746,
        year: 31556952
    },
    currency: {
        // This will be populated dynamically with exchange rates
    },
    scientific: {
        // Metric prefixes for base unit (e.g., meter)
        yotta: { value: 1e24, symbol: 'Y' },
        zetta: { value: 1e21, symbol: 'Z' },
        exa: { value: 1e18, symbol: 'E' },
        peta: { value: 1e15, symbol: 'P' },
        tera: { value: 1e12, symbol: 'T' },
        giga: { value: 1e9, symbol: 'G' },
        mega: { value: 1e6, symbol: 'M' },
        kilo: { value: 1e3, symbol: 'k' },
        hecto: { value: 1e2, symbol: 'h' },
        deca: { value: 1e1, symbol: 'da' },
        base: { value: 1, symbol: '' },
        deci: { value: 1e-1, symbol: 'd' },
        centi: { value: 1e-2, symbol: 'c' },
        milli: { value: 1e-3, symbol: 'm' },
        micro: { value: 1e-6, symbol: 'μ' },
        nano: { value: 1e-9, symbol: 'n' },
        pico: { value: 1e-12, symbol: 'p' },
        femto: { value: 1e-15, symbol: 'f' },
        atto: { value: 1e-18, symbol: 'a' },
        zepto: { value: 1e-21, symbol: 'z' },
        yocto: { value: 1e-24, symbol: 'y' }
    },
    pressure: {
        pascal: 1,
        kilopascal: 1000,
        megapascal: 1000000,
        bar: 100000,
        psi: 6894.76,
        atmosphere: 101325,
        torr: 133.322,
        mmHg: 133.322
    },
    energy: {
        joule: 1,
        kilojoule: 1000,
        calorie: 4.184,
        kilocalorie: 4184,
        watthour: 3600,
        kilowatthour: 3600000,
        electronvolt: 1.602176634e-19,
        btu: 1055.06
    },
    power: {
        watt: 1,
        kilowatt: 1000,
        megawatt: 1000000,
        horsepower: 745.7,
        btuPerHour: 0.29307107
    },
    torque: {
        newtonMeter: 1,
        newtonCentimeter: 0.01,
        newtonMillimeter: 0.001,
        kilogramForceMeter: 9.80665,
        kilogramForceCentimeter: 0.0980665,
        poundForceFoot: 1.355818,
        poundForceInch: 0.112985,
        ounceForceFoot: 0.084738,
        ounceForceInch: 0.007062
    },
    viscosity: {
        pascalSecond: 1,
        poise: 0.1,
        centipoise: 0.001,
        squareMeterPerSecond: 1,
        stokes: 0.0001,
        centistokes: 0.000001
    },
    force: {
        newton: 1,
        kilonewton: 1000,
        dyne: 0.00001,
        kilogramForce: 9.80665,
        poundForce: 4.448222,
        ounceForce: 0.278014
    },
    frequency: {
        hertz: 1,
        kilohertz: 1000,
        megahertz: 1000000,
        gigahertz: 1000000000,
        cyclesPerSecond: 1,
        cyclesPerMinute: 0.016667,
        radiansPerSecond: 0.159155,
        degreesPerSecond: 0.002778
    },
    angle: {
        degree: 1,
        radian: 57.2958,
        gradian: 0.9,
        milliradian: 0.057296,
        minuteOfArc: 0.016667,
        secondOfArc: 0.000278,
        turn: 360
    },
    density: {
        kilogramPerCubicMeter: 1,
        gramPerCubicCentimeter: 1000,
        kilogramPerLiter: 1000,
        gramPerMilliliter: 1000,
        poundPerCubicFoot: 16.018463,
        poundPerCubicInch: 27679.905,
        poundPerGallon: 119.826427
    },
    pace: {
        minPerKm: 1,           // Base unit (minutes per kilometer)
        minPerMile: 1.60934,   // minutes per mile
        kmPerHour: 0.06,       // kilometers per hour (converted to min/km)
        milesPerHour: 0.0372823,  // miles per hour (converted to min/km)
        secPerKm: 0.0166667,   // seconds per kilometer
        secPerMile: 0.0268224  // seconds per mile
    }
};

// DOM Elements
const categorySelect = document.getElementById('category');
const fromUnitSelect = document.getElementById('fromUnit');
const toUnitSelect = document.getElementById('toUnit');
const fromValueInput = document.getElementById('fromValue');
const toValueInput = document.getElementById('toValue');
const swapBtn = document.getElementById('swapBtn');
const resultDiv = document.getElementById('result');
const historyList = document.getElementById('historyList');
const clearHistoryBtn = document.getElementById('clearHistory');
const languageSelect = document.getElementById('language');
const themeSelect = document.getElementById('theme');
const searchInput = document.getElementById('searchInput');
const searchResults = document.getElementById('searchResults');
const favoriteBtn = document.getElementById('favoriteBtn');
const favoritesSection = document.getElementById('favoritesSection');
const favoritesList = document.getElementById('favoritesList');

// Load conversion histories from localStorage
let conversionHistories = JSON.parse(localStorage.getItem('conversionHistories')) || {
    length: [],
    mass: [],
    temperature: [],
    volume: [],
    area: [],
    speed: [],
    time: [],
    currency: [],
    scientific: [],
    pressure: [],
    energy: [],
    power: [],
    torque: [],
    viscosity: [],
    force: [],
    frequency: [],
    angle: [],
    density: [],
    pace: []
};

// Load calculator and physics histories
let calculatorHistory = JSON.parse(localStorage.getItem('calculatorHistory')) || [];
let physicsHistory = JSON.parse(localStorage.getItem('physicsHistory')) || {
    freefall: [],
    suvat: [],
    projectile: [],
    forces: []
};

// Current category's history
let currentHistory = [];

// Debounce timer
let addToHistoryTimer = null;

// Add exchange rate management
let exchangeRates = {};
let lastRatesUpdate = null;

// Add theme management
let currentTheme = localStorage.getItem('preferredTheme') || 'system';

// Load favorites from localStorage
let favorites = JSON.parse(localStorage.getItem('favorites')) || [];

// DOM Elements for calculator
const calcDisplay = document.getElementById('calcDisplay');
const calculatorButtons = document.getElementById('calculatorButtons');
const calculatorMode = document.getElementById('calculatorMode');

let currentCalculation = '0';
let shouldResetDisplay = false;
let isScientificMode = localStorage.getItem('calculatorMode') === 'scientific';

// Calculator functions
const calculatorFunctions = {
    'sin': x => Math.sin(x * Math.PI / 180),
    'cos': x => Math.cos(x * Math.PI / 180),
    'tan': x => Math.tan(x * Math.PI / 180),
    'log': x => Math.log10(x),
    'ln': x => Math.log(x),
    'x²': x => x * x,
    '√': x => Math.sqrt(x),
    'π': () => Math.PI,
    'e': () => Math.E,
    '|x|': x => Math.abs(x),
    'x!': x => {
        if (x < 0) return NaN;
        if (x === 0) return 1;
        let result = 1;
        for (let i = 2; i <= x; i++) result *= i;
        return result;
    }
};

// Add physics constants at the top of the file
const GRAVITY = 9.81; // m/s²
const AIR_DENSITY = 1.225; // kg/m³
const DRAG_COEFFICIENT = 0.47; // for a sphere

// Unit conversion constants
const unitConversions = {
    mass: {
        'kg': 1,
        'g': 0.001,
        'lb': 0.453592,
        'oz': 0.0283495
    },
    length: {
        'm': 1,
        'km': 1000,
        'cm': 0.01,
        'ft': 0.3048,
        'in': 0.0254,
        'mi': 1609.34
    }
};

// Main initialization
document.addEventListener('DOMContentLoaded', () => {
    // Tab switching
    const tabBtns = document.querySelectorAll('.tab-btn');
    const tabPanes = document.querySelectorAll('.tab-pane');

    tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const targetTab = btn.dataset.tab;
            
            // Update active tab button
            tabBtns.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            // Show corresponding tab pane
            tabPanes.forEach(pane => {
                pane.classList.remove('active');
                if (pane.id === `${targetTab}Pane`) {
                    pane.classList.add('active');
                }
            });

            // Add history display on tab switch
            if (targetTab === 'calculator') {
                displayCalculatorHistory();
            } else if (targetTab === 'physics') {
                const activePhysicsTab = document.querySelector('.physics-tab.active');
                if (activePhysicsTab) {
                    displayPhysicsHistory(activePhysicsTab.dataset.tab);
                }
            }
        });
    });

    // Initialize the converter
    initializeConverter();
    fetchExchangeRates();
    
    // Initialize calculator functionality
    const calculatorBtns = document.querySelectorAll('.calculator-buttons .calc-btn');
    calculatorBtns.forEach(button => {
        button.addEventListener('click', handleCalculatorClick);
    });

    // Initialize calculator mode
    if (calculatorMode) {
        calculatorMode.checked = isScientificMode;
        calculatorButtons.classList.toggle('simple', !isScientificMode);

        calculatorMode.addEventListener('change', (e) => {
            isScientificMode = e.target.checked;
            calculatorButtons.classList.toggle('simple', !isScientificMode);
            localStorage.setItem('calculatorMode', isScientificMode ? 'scientific' : 'simple');
        });
    }

    // Initialize physics calculation buttons
    const calculateFreefall = document.getElementById('calculateFreefall');
    const calculateSuvat = document.getElementById('calculateSuvat');
    const calculateProjectile = document.getElementById('calculateProjectile');
    const calculateForces = document.getElementById('calculateForces');

    if (calculateFreefall) {
        calculateFreefall.addEventListener('click', handleFreefallCalculation);
    }
    if (calculateSuvat) {
        calculateSuvat.addEventListener('click', handleSuvatCalculation);
    }
    if (calculateProjectile) {
        calculateProjectile.addEventListener('click', handleProjectileCalculation);
    }
    if (calculateForces) {
        calculateForces.addEventListener('click', handleForcesCalculation);
    }

    // Initialize physics tabs
    const physicsTabs = document.querySelectorAll('.physics-tab');
    const physicsSections = document.querySelectorAll('.physics-section');

    physicsTabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const targetTab = tab.dataset.tab;
            
            // Update active tab
            physicsTabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            
            // Show corresponding section
            physicsSections.forEach(section => {
                section.classList.add('hidden');
                if (section.id === `${targetTab}Section`) {
                    section.classList.remove('hidden');
                }
            });

            // Display history for the active tab
            displayPhysicsHistory(targetTab);
        });
    });
});

// Handle calculator button clicks
function handleCalculatorClick() {
    const value = this.textContent;
    
    if (value === 'C') {
        currentCalculation = '0';
        calcDisplay.textContent = '0';
        shouldResetDisplay = false;
        return;
    }
    
    if (value === '=') {
        try {
            let calculation = currentCalculation.replace(/×/g, '*').replace(/÷/g, '/');
            const result = eval(calculation);
            calcDisplay.textContent = Number.isInteger(result) ? result : result.toFixed(8);
            currentCalculation = calcDisplay.textContent;
            shouldResetDisplay = true;

            // Add to calculator history
            addToCalculatorHistory(calculation, result);
            displayCalculatorHistory();
        } catch (error) {
            calcDisplay.textContent = 'Error';
            currentCalculation = '0';
            shouldResetDisplay = true;
        }
        return;
    }
    
    // Handle scientific functions
    if (this.classList.contains('function')) {
        if (value === 'π' || value === 'e') {
            const result = calculatorFunctions[value]();
            currentCalculation = result.toString();
            calcDisplay.textContent = currentCalculation;
            shouldResetDisplay = true;
            return;
        }
        
        try {
            const currentValue = parseFloat(currentCalculation);
            const result = calculatorFunctions[value](currentValue);
            currentCalculation = result.toString();
            calcDisplay.textContent = Number.isInteger(result) ? result : result.toFixed(8);
            shouldResetDisplay = true;
        } catch (error) {
            calcDisplay.textContent = 'Error';
            currentCalculation = '0';
            shouldResetDisplay = true;
        }
        return;
    }
    
    // Handle regular input
    if (shouldResetDisplay) {
        currentCalculation = value;
        shouldResetDisplay = false;
    } else {
        currentCalculation = currentCalculation === '0' ? value : currentCalculation + value;
    }
    
    calcDisplay.textContent = currentCalculation;
}

// Handle physics calculations
function handleFreefallCalculation() {
    const massValue = parseFloat(document.getElementById('objectMass').value);
    const sizeValue = parseFloat(document.getElementById('objectSize').value);
    const heightValue = parseFloat(document.getElementById('fallHeight').value);

    const massUnit = document.getElementById('massUnit').value;
    const sizeUnit = document.getElementById('sizeUnit').value;
    const heightUnit = document.getElementById('heightUnit').value;

    const freefallResult = document.getElementById('freefallResult');

    if (isNaN(massValue) || isNaN(sizeValue) || isNaN(heightValue)) {
        freefallResult.textContent = 'Please fill in all fields with valid numbers.';
        return;
    }

    // Convert to base units (kg and m)
    const mass = massValue * unitConversions.mass[massUnit];
    const size = sizeValue * unitConversions.length[sizeUnit];
    const height = heightValue * unitConversions.length[heightUnit];

    // Calculate free fall with air resistance
    const area = Math.PI * Math.pow(size/2, 2); // Cross-sectional area
    const k = 0.5 * AIR_DENSITY * DRAG_COEFFICIENT * area; // Air resistance coefficient

    // Terminal velocity
    const terminalVelocity = Math.sqrt((mass * GRAVITY) / k);

    // Calculate motion with time steps
    const timeSteps = 100;
    const dt = Math.sqrt((2 * height) / GRAVITY) / timeSteps;
    let position = height;
    let velocity = 0;
    let time = 0;
    const timePoints = [];
    const positionPoints = [];
    const velocityPoints = [];

    while (position > 0) {
        timePoints.push(time);
        positionPoints.push(position);
        velocityPoints.push(velocity);

        const acceleration = GRAVITY - (k * velocity * Math.abs(velocity)) / mass;
        velocity += acceleration * dt;
        position -= velocity * dt;
        time += dt;
    }

    // Create position vs time graph
    const ctx = document.getElementById('freefallChart').getContext('2d');
    if (window.freefallChart) {
        window.freefallChart.destroy();
    }
    window.freefallChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: timePoints.map(t => t.toFixed(2)),
            datasets: [{
                label: 'Height (m)',
                data: positionPoints,
                borderColor: '#4C51BF',
                tension: 0.4
            }, {
                label: 'Velocity (m/s)',
                data: velocityPoints,
                borderColor: '#48BB78',
                tension: 0.4
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Time (s)'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Height (m) / Velocity (m/s)'
                    }
                }
            }
        }
    });

    // Display results
    freefallResult.textContent = `
Time to fall: ${time.toFixed(2)} seconds
Terminal velocity: ${terminalVelocity.toFixed(2)} m/s
Maximum speed reached: ${Math.min(Math.max(...velocityPoints), terminalVelocity).toFixed(2)} m/s

Input values:
Mass: ${massValue} ${massUnit} (${mass.toFixed(3)} kg)
Size: ${sizeValue} ${sizeUnit} (${size.toFixed(3)} m)
Height: ${heightValue} ${heightUnit} (${height.toFixed(3)} m)`;

    // Add to history
    addToPhysicsHistory('freefall', {
        objectMass: massValue,
        objectSize: sizeValue,
        fallHeight: heightValue,
        massUnit,
        sizeUnit,
        heightUnit
    }, freefallResult.textContent);
    
    displayPhysicsHistory('freefall');
}

function handleSuvatCalculation() {
    const s = parseFloat(document.getElementById('suvatS').value);
    const u = parseFloat(document.getElementById('suvatU').value);
    const v = parseFloat(document.getElementById('suvatV').value);
    const a = parseFloat(document.getElementById('suvatA').value);
    const t = parseFloat(document.getElementById('suvatT').value);

    const sUnit = document.getElementById('suvatSUnit').value;
    const vUnit = document.getElementById('suvatVUnit').value;

    const suvatResult = document.getElementById('suvatResult');

    // Convert to base units
    const displacement = s * unitConversions.length[sUnit];
    const initialVelocity = vUnit === 'kmh' ? u / 3.6 : u;
    const finalVelocity = vUnit === 'kmh' ? v / 3.6 : v;

    // Calculate missing values using SUVAT equations
    let results = {};
    if (!isNaN(u) && !isNaN(a) && !isNaN(t)) {
        results = {
            s: initialVelocity * t + 0.5 * a * t * t,
            v: initialVelocity + a * t
        };
    } else if (!isNaN(u) && !isNaN(v) && !isNaN(t)) {
        results = {
            s: 0.5 * (initialVelocity + finalVelocity) * t,
            a: (finalVelocity - initialVelocity) / t
        };
    }

    // Create motion graph
    const timePoints = Array.from({length: 100}, (_, i) => i * (t / 100));
    const positionPoints = timePoints.map(time => 
        initialVelocity * time + 0.5 * a * time * time
    );
    const velocityPoints = timePoints.map(time =>
        initialVelocity + a * time
    );

    const ctx = document.getElementById('suvatChart').getContext('2d');
    if (window.suvatChart) {
        window.suvatChart.destroy();
    }
    window.suvatChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: timePoints,
            datasets: [{
                label: 'Position (m)',
                data: positionPoints,
                borderColor: '#4C51BF',
                tension: 0.4
            }, {
                label: 'Velocity (m/s)',
                data: velocityPoints,
                borderColor: '#48BB78',
                tension: 0.4
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Time (s)'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Position (m) / Velocity (m/s)'
                    }
                }
            }
        }
    });

    // Display results
    suvatResult.textContent = `
Calculated values:
${Object.entries(results).map(([key, value]) => 
    `${key.toUpperCase()}: ${value.toFixed(2)} ${key === 's' ? 'm' : key === 'v' ? 'm/s' : 'm/s²'}`
).join('\n')}`;

    // Add to history
    addToPhysicsHistory('suvat', {
        suvatS: s,
        suvatU: u,
        suvatV: v,
        suvatA: a,
        suvatT: t,
        suvatSUnit: sUnit,
        suvatVUnit: vUnit
    }, suvatResult.textContent);
    
    displayPhysicsHistory('suvat');
}

function handleProjectileCalculation() {
    const velocity = parseFloat(document.getElementById('projVelocity').value);
    const angle = parseFloat(document.getElementById('projAngle').value);
    const height = parseFloat(document.getElementById('projHeight').value);

    const vUnit = document.getElementById('projVUnit').value;
    const hUnit = document.getElementById('projHUnit').value;

    const projectileResult = document.getElementById('projectileResult');

    if (isNaN(velocity) || isNaN(angle) || isNaN(height)) {
        projectileResult.textContent = 'Please fill in all fields with valid numbers.';
        return;
    }

    // Convert to base units
    const v0 = vUnit === 'kmh' ? velocity / 3.6 : velocity;
    const h0 = height * unitConversions.length[hUnit];
    const theta = angle * Math.PI / 180;

    // Initial velocities
    const v0x = v0 * Math.cos(theta);
    const v0y = v0 * Math.sin(theta);

    // Time of flight
    const a = -GRAVITY/2;
    const b = v0y;
    const c = h0;
    const timeOfFlight = (-b + Math.sqrt(b*b - 4*a*c))/(2*a);

    // Maximum height
    const maxHeight = h0 + (v0y * v0y)/(2 * GRAVITY);

    // Range
    const range = v0x * timeOfFlight;

    // Generate points for trajectory
    const timePoints = Array.from({length: 100}, (_, i) => i * (timeOfFlight / 100));
    const xPoints = timePoints.map(t => v0x * t);
    const yPoints = timePoints.map(t => h0 + v0y * t - 0.5 * GRAVITY * t * t);

    // Create trajectory graph
    const ctx = document.getElementById('projectileChart').getContext('2d');
    if (window.projectileChart) {
        window.projectileChart.destroy();
    }
    window.projectileChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                label: 'Trajectory',
                data: timePoints.map((_, i) => ({
                    x: xPoints[i],
                    y: yPoints[i]
                })),
                borderColor: '#4C51BF',
                showLine: true,
                tension: 0.4
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Distance (m)'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Height (m)'
                    }
                }
            }
        }
    });

    // Display results
    projectileResult.textContent = `
Time of flight: ${timeOfFlight.toFixed(2)} s
Maximum height: ${maxHeight.toFixed(2)} m
Range: ${range.toFixed(2)} m
Initial velocity: ${v0.toFixed(2)} m/s
Launch angle: ${angle}°`;

    // Add to history
    addToPhysicsHistory('projectile', {
        projVelocity: velocity,
        projAngle: angle,
        projHeight: height,
        projVUnit: vUnit,
        projHUnit: hUnit
    }, projectileResult.textContent);
    
    displayPhysicsHistory('projectile');
}

function handleForcesCalculation() {
    const mass = parseFloat(document.getElementById('forceMass').value);
    const accel = parseFloat(document.getElementById('forceAccel').value);
    const friction = parseFloat(document.getElementById('forceFriction').value);

    const mUnit = document.getElementById('forceMUnit').value;
    const m = mUnit === 'g' ? mass / 1000 : mass;

    const forcesResult = document.getElementById('forcesResult');

    if (isNaN(mass) || isNaN(accel) || isNaN(friction)) {
        forcesResult.textContent = 'Please fill in all fields with valid numbers.';
        return;
    }

    // Calculate forces
    const weight = m * GRAVITY;
    const normal = weight;
    const frictionForce = friction * normal;
    const netForce = m * accel;
    const appliedForce = netForce + frictionForce;

    // Draw force diagram
    const canvas = document.getElementById('forcesDiagram');
    const ctx = canvas.getContext('2d');
    
    // Clear previous drawing
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Set canvas size to match container
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    // Draw block
    const blockSize = 50;
    const x = canvas.width / 2;
    const y = canvas.height / 2;
    
    ctx.fillStyle = '#4C51BF';
    ctx.fillRect(x - blockSize/2, y - blockSize/2, blockSize, blockSize);

    // Draw forces as arrows
    const drawArrow = (fromX, fromY, toX, toY, color, label) => {
        const headLength = 10;
        const angle = Math.atan2(toY - fromY, toX - fromX);
        
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI/6),
                  toY - headLength * Math.sin(angle - Math.PI/6));
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI/6),
                  toY - headLength * Math.sin(angle + Math.PI/6));
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.fillStyle = color;
        ctx.fillText(label, toX + 5, toY);
    };

    // Draw force arrows
    const scale = 50 / Math.max(weight, appliedForce, frictionForce);
    drawArrow(x, y, x, y - weight * scale, '#48BB78', `Weight: ${weight.toFixed(1)}N`);
    drawArrow(x, y, x + appliedForce * scale, y, '#4C51BF', `Applied: ${appliedForce.toFixed(1)}N`);
    drawArrow(x, y, x - frictionForce * scale, y, '#E53E3E', `Friction: ${frictionForce.toFixed(1)}N`);
    drawArrow(x, y, x, y + normal * scale, '#48BB78', `Normal: ${normal.toFixed(1)}N`);

    // Display results
    forcesResult.textContent = `
Weight: ${weight.toFixed(2)} N
Normal force: ${normal.toFixed(2)} N
Friction force: ${frictionForce.toFixed(2)} N
Net force: ${netForce.toFixed(2)} N
Applied force: ${appliedForce.toFixed(2)} N`;

    // Add to history
    addToPhysicsHistory('forces', {
        forceMass: mass,
        forceAccel: accel,
        forceFriction: friction,
        forceMUnit: mUnit
    }, forcesResult.textContent);
    
    displayPhysicsHistory('forces');
}

function convertToBaseUnit(value, unit, type) {
    return value * unitConversions[type][unit];
}

// Open physics calculator
openPhysicsBtn.addEventListener('click', () => {
    physicsModal.classList.add('show');
    document.querySelector('.physics-calculator').classList.add('show');
});

// Close physics calculator
closePhysicsBtn.addEventListener('click', () => {
    physicsModal.classList.remove('show');
});

// Close physics calculator when clicking outside
physicsModal.addEventListener('click', (e) => {
    if (e.target === physicsModal) {
        physicsModal.classList.remove('show');
    }
});

// Calculate physics problems
calculatePhysicsBtn.addEventListener('click', () => {
    const massValue = parseFloat(document.getElementById('objectMass').value);
    const sizeValue = parseFloat(document.getElementById('objectSize').value);
    const heightValue = parseFloat(document.getElementById('fallHeight').value);

    const massUnit = document.getElementById('massUnit').value;
    const sizeUnit = document.getElementById('sizeUnit').value;
    const heightUnit = document.getElementById('heightUnit').value;

    if (isNaN(massValue) || isNaN(sizeValue) || isNaN(heightValue)) {
        physicsResult.textContent = 'Please fill in all fields with valid numbers.';
        return;
    }

    if (massValue <= 0 || sizeValue <= 0 || heightValue <= 0) {
        physicsResult.textContent = 'All values must be greater than zero.';
        return;
    }

    // Convert all inputs to base units (kg and m)
    const mass = convertToBaseUnit(massValue, massUnit, 'mass');
    const size = convertToBaseUnit(sizeValue, sizeUnit, 'length');
    const height = convertToBaseUnit(heightValue, heightUnit, 'length');

    // Calculate free fall with air resistance
    const area = Math.PI * Math.pow(size/2, 2); // Cross-sectional area
    const k = 0.5 * AIR_DENSITY * DRAG_COEFFICIENT * area; // Air resistance coefficient

    // Terminal velocity
    const terminalVelocity = Math.sqrt((mass * GRAVITY) / k);

    // Time to fall (numerical approximation)
    let time = 0;
    let position = height;
    let velocity = 0;
    const dt = 0.01; // Time step for numerical integration

    while (position > 0) {
        const acceleration = GRAVITY - (k * velocity * Math.abs(velocity)) / mass;
        velocity += acceleration * dt;
        position -= velocity * dt;
        time += dt;
    }

    // Time without air resistance for comparison
    const timeNoResistance = Math.sqrt((2 * height) / GRAVITY);
    
    // Format results with original units
    const results = `Results:
Time to fall: ${time.toFixed(2)} seconds
Terminal velocity: ${terminalVelocity.toFixed(2)} m/s
Maximum speed reached: ${Math.min(velocity, terminalVelocity).toFixed(2)} m/s

Input values:
Mass: ${massValue} ${massUnit} (${mass.toFixed(3)} kg)
Size: ${sizeValue} ${sizeUnit} (${size.toFixed(3)} m)
Height: ${heightValue} ${heightUnit} (${height.toFixed(3)} m)

For comparison:
Time without air resistance: ${timeNoResistance.toFixed(2)} seconds
Difference due to air resistance: ${(time - timeNoResistance).toFixed(2)} seconds

Additional info:
- Air density used: ${AIR_DENSITY} kg/m³
- Drag coefficient: ${DRAG_COEFFICIENT} (sphere)
- Cross-sectional area: ${area.toFixed(4)} m²`;

    physicsResult.textContent = results;

    // Add to history
    addToPhysicsHistory('freefall', {
        objectMass: massValue,
        objectSize: sizeValue,
        fallHeight: heightValue,
        massUnit,
        sizeUnit,
        heightUnit
    }, document.getElementById('physicsResult').textContent);
    
    displayPhysicsHistory('freefall');
});

async function fetchExchangeRates() {
    try {
        const response = await fetch('https://api.exchangerate-api.com/v4/latest/USD');
        const data = await response.json();
        exchangeRates = data.rates;
        lastRatesUpdate = new Date();
        unitData.currency = exchangeRates;
        
        // Update the UI if we're on the currency category
        if (categorySelect.value === 'currency') {
            updateUnitSelects();
            convert();
        }
        
        return true;
    } catch (error) {
        console.error('Error fetching exchange rates:', error);
        return false;
    }
}

// Update page language
function updateLanguage(lang) {
    currentLanguage = lang;
    localStorage.setItem('preferredLanguage', lang);
    
    // Update all elements with data-lang attribute
    document.querySelectorAll('[data-lang]').forEach(element => {
        const key = element.getAttribute('data-lang');
        element.textContent = translations[lang][key];
    });

    // Update placeholders
    document.querySelectorAll('[data-lang-placeholder]').forEach(element => {
        const key = element.getAttribute('data-lang-placeholder');
        element.placeholder = translations[lang][key];
    });

    // Update tooltips
    swapBtn.title = translations[lang].swap_tooltip;

    // Update category options
    Array.from(categorySelect.options).forEach(option => {
        const key = option.getAttribute('data-lang');
        if (key) {
            option.textContent = translations[lang][key];
        }
    });

    // Refresh history display to update any text
    displayHistory();
}

// Function to set theme
function setTheme(theme) {
    currentTheme = theme;
    localStorage.setItem('preferredTheme', theme);
    
    if (theme === 'system') {
        // Remove any manual theme
        document.body.removeAttribute('data-theme');
        // Apply theme based on system preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.body.setAttribute('data-theme', 'dark');
        } else {
            document.body.setAttribute('data-theme', 'light');
        }
    } else {
        document.body.setAttribute('data-theme', theme);
    }
}

// Watch for system theme changes
if (window.matchMedia) {
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        if (currentTheme === 'system') {
            setTheme('system');
        }
    });
}

// Initialize the converter
function initializeConverter() {
    // Event listeners
    categorySelect.addEventListener('change', handleCategoryChange);
    fromUnitSelect.addEventListener('change', convert);
    toUnitSelect.addEventListener('change', convert);
    fromValueInput.addEventListener('input', convert);
    swapBtn.addEventListener('click', swapUnits);
    clearHistoryBtn.addEventListener('click', clearHistory);
    languageSelect.addEventListener('change', (e) => updateLanguage(e.target.value));
    themeSelect.addEventListener('change', (e) => setTheme(e.target.value));

    // Add theme initialization
    themeSelect.value = currentTheme;
    setTheme(currentTheme);

    // Set initial language
    languageSelect.value = currentLanguage;
    updateLanguage(currentLanguage);

    // Add search and favorites event listeners
    searchInput.addEventListener('input', (e) => {
        const query = e.target.value.trim();
        if (query) {
            handleSearch(query);
        } else {
            searchResults.classList.remove('show');
        }
    });

    document.addEventListener('click', (e) => {
        if (!searchResults.contains(e.target) && !searchInput.contains(e.target)) {
            searchResults.classList.remove('show');
        }
    });

    favoriteBtn.addEventListener('click', toggleFavorite);

    // Initialize favorites
    displayFavorites();

    // Initial setup
    handleCategoryChange();
}

// Update handleCategoryChange function
function handleCategoryChange() {
    const category = categorySelect.value;
    currentHistory = conversionHistories[category];
    
    // Reset the From field
    fromValueInput.value = '';
    toValueInput.value = '';
    resultDiv.textContent = translations[currentLanguage].initial_message;
    
    // If switching to currency, fetch latest rates if needed
    if (category === 'currency' && (!lastRatesUpdate || Date.now() - lastRatesUpdate.getTime() > 3600000)) {
        resultDiv.textContent = translations[currentLanguage].loading_rates;
        fetchExchangeRates().then(success => {
            if (!success) {
                resultDiv.textContent = translations[currentLanguage].error_rates;
            }
        });
    }
    
    updateUnitSelects();
    displayHistory();
    updateFavoriteButton();
}

// Update unit select options based on category
function updateUnitSelects() {
    const category = categorySelect.value;
    const units = Object.keys(unitData[category]);
    
    // Clear existing options
    fromUnitSelect.innerHTML = '';
    toUnitSelect.innerHTML = '';
    
    // Add new options
    units.forEach(unit => {
        const fromOption = new Option(unit, unit);
        const toOption = new Option(unit, unit);
        fromUnitSelect.add(fromOption);
        toUnitSelect.add(toOption);
    });
    
    // Set default selections
    if (category === 'temperature') {
        fromUnitSelect.value = 'celsius';
        toUnitSelect.value = 'fahrenheit';
    } else {
        toUnitSelect.selectedIndex = 1;
    }
    
    convert();
}

// Swap units and values
function swapUnits() {
    const tempUnit = fromUnitSelect.value;
    const tempValue = fromValueInput.value;
    
    fromUnitSelect.value = toUnitSelect.value;
    toUnitSelect.value = tempUnit;
    
    fromValueInput.value = toValueInput.value;
    convert();
}

// Convert units
function convert() {
    const category = categorySelect.value;
    const fromUnit = fromUnitSelect.value;
    const toUnit = toUnitSelect.value;
    const fromValue = parseFloat(fromValueInput.value);

    if (isNaN(fromValue)) {
        toValueInput.value = '';
        resultDiv.textContent = 'Enter a valid number';
        return;
    }

    let result;
    if (category === 'temperature') {
        result = convertTemperature(fromValue, fromUnit, toUnit);
    } else if (category === 'currency') {
        if (!exchangeRates[fromUnit] || !exchangeRates[toUnit]) {
            toValueInput.value = '';
            resultDiv.textContent = translations[currentLanguage].error_rates;
            return;
        }
        const usdAmount = fromValue / exchangeRates[fromUnit];
        result = usdAmount * exchangeRates[toUnit];
    } else if (category === 'scientific') {
        const fromPrefix = unitData.scientific[fromUnit];
        const toPrefix = unitData.scientific[toUnit];
        result = fromValue * (fromPrefix.value / toPrefix.value);
    } else if (category === 'pace') {
        result = convertPace(fromValue, fromUnit, toUnit);
    } else {
        const baseValue = fromValue * unitData[category][fromUnit];
        result = baseValue / unitData[category][toUnit];
    }

    toValueInput.value = result.toFixed(6);
    let conversionText = `${fromValue} ${fromUnit} = ${result.toFixed(6)} ${toUnit}`;
    
    // Add prefix symbols for scientific units
    if (category === 'scientific') {
        const fromPrefix = unitData.scientific[fromUnit];
        const toPrefix = unitData.scientific[toUnit];
        conversionText = `${fromValue} ${fromPrefix.symbol}${translations[currentLanguage].prefix_base} = ${result.toFixed(6)} ${toPrefix.symbol}${translations[currentLanguage].prefix_base}`;
    }
    
    resultDiv.textContent = conversionText;

    if (category === 'currency') {
        resultDiv.textContent += `\n${translations[currentLanguage].last_updated}: ${lastRatesUpdate.toLocaleString()}`;
    }

    // Clear any existing timer
    if (addToHistoryTimer) {
        clearTimeout(addToHistoryTimer);
    }

    // Set a new timer to add to history after 1 second of no changes
    addToHistoryTimer = setTimeout(() => {
        addToHistory({
            category,
            fromValue,
            fromUnit,
            toValue: result,
            toUnit,
            timestamp: new Date().toISOString()
        });
    }, 1000);

    updateFavoriteButton();
}

// Special handling for temperature conversions
function convertTemperature(value, fromUnit, toUnit) {
    if (fromUnit === toUnit) return value;
    
    let celsius;
    // Convert to Celsius first
    switch (fromUnit) {
        case 'celsius':
            celsius = value;
            break;
        case 'fahrenheit':
            celsius = (value - 32) * 5/9;
            break;
        case 'kelvin':
            celsius = value - 273.15;
            break;
    }
    
    // Convert from Celsius to target unit
    switch (toUnit) {
        case 'celsius':
            return celsius;
        case 'fahrenheit':
            return (celsius * 9/5) + 32;
        case 'kelvin':
            return celsius + 273.15;
    }
}

// Pace conversion
function convertPace(value, fromUnit, toUnit) {
    if (fromUnit === toUnit) return value;
    
    let pace;
    // Convert to pace format
    switch (fromUnit) {
        case 'minPerKm':
            pace = value;
            break;
        case 'minPerMile':
            pace = value;
            break;
        case 'kmPerHour':
            pace = 60 / value;
            break;
        case 'milesPerHour':
            pace = 60 / value;
            break;
        case 'secPerKm':
            pace = 1 / value;
            break;
        case 'secPerMile':
            pace = 1 / value;
            break;
    }
    
    // Convert from pace format to target unit
    switch (toUnit) {
        case 'minPerKm':
            return pace;
        case 'minPerMile':
            return pace;
        case 'kmPerHour':
            return 60 / pace;
        case 'milesPerHour':
            return 60 / pace;
        case 'secPerKm':
            return 1 / pace;
        case 'secPerMile':
            return 1 / pace;
    }
}

// History management functions
function addToHistory(conversion) {
    const category = conversion.category;
    conversionHistories[category].unshift(conversion);
    // Keep only the last 10 conversions per category
    conversionHistories[category] = conversionHistories[category].slice(0, 10);
    localStorage.setItem('conversionHistories', JSON.stringify(conversionHistories));
    displayHistory();
}

function displayHistory() {
    historyList.innerHTML = '';
    const category = categorySelect.value;
    const categoryHistory = conversionHistories[category];

    if (categoryHistory.length === 0) {
        const emptyMessage = document.createElement('div');
        emptyMessage.className = 'history-item';
        emptyMessage.style.justifyContent = 'center';
        emptyMessage.style.color = '#666';
        emptyMessage.textContent = `No ${category} conversions yet`;
        historyList.appendChild(emptyMessage);
        return;
    }

    categoryHistory.forEach((conversion, index) => {
        const historyItem = document.createElement('div');
        historyItem.className = 'history-item';
        
        const conversionText = document.createElement('span');
        conversionText.textContent = `${conversion.fromValue} ${conversion.fromUnit} = ${conversion.toValue.toFixed(6)} ${conversion.toUnit}`;
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'history-item-buttons';

        const copyButton = document.createElement('button');
        copyButton.className = 'copy-btn';
        copyButton.textContent = '📋';
        copyButton.title = translations[currentLanguage].copy_tooltip;
        
        const tooltip = document.createElement('span');
        tooltip.className = 'copy-tooltip';
        tooltip.textContent = isMobile() ? 
            translations[currentLanguage].copy_tooltip_mobile : 
            translations[currentLanguage].copy_tooltip;
        copyButton.appendChild(tooltip);
        
        copyButton.onclick = () => copyToClipboard(conversionText.textContent, tooltip);

        const reloadButton = document.createElement('button');
        reloadButton.className = 'reload-btn';
        reloadButton.textContent = '↺';
        reloadButton.title = translations[currentLanguage].reload_tooltip;
        reloadButton.onclick = () => reloadConversion(conversion);
        
        const deleteButton = document.createElement('button');
        deleteButton.className = 'delete-btn';
        deleteButton.textContent = '×';
        deleteButton.title = translations[currentLanguage].delete_tooltip;
        deleteButton.onclick = () => deleteHistoryItem(category, index);
        
        buttonsContainer.appendChild(copyButton);
        buttonsContainer.appendChild(reloadButton);
        buttonsContainer.appendChild(deleteButton);
        
        historyItem.appendChild(conversionText);
        historyItem.appendChild(buttonsContainer);
        historyList.appendChild(historyItem);
    });
}

function reloadConversion(conversion) {
    categorySelect.value = conversion.category;
    updateUnitSelects();
    
    fromUnitSelect.value = conversion.fromUnit;
    toUnitSelect.value = conversion.toUnit;
    fromValueInput.value = conversion.fromValue;
    
    convert();
}

function deleteHistoryItem(category, index) {
    conversionHistories[category].splice(index, 1);
    localStorage.setItem('conversionHistories', JSON.stringify(conversionHistories));
    displayHistory();
}

function clearHistory() {
    const category = categorySelect.value;
    conversionHistories[category] = [];
    localStorage.setItem('conversionHistories', JSON.stringify(conversionHistories));
    displayHistory();
}

// Function to detect if user is on mobile
function isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

// Function to copy text to clipboard and show feedback
async function copyToClipboard(text, tooltip) {
    try {
        await navigator.clipboard.writeText(text);
        
        // Show "Copied!" message
        tooltip.textContent = translations[currentLanguage].copied_tooltip;
        tooltip.classList.add('show');
        
        // Reset tooltip after 2 seconds
        setTimeout(() => {
            tooltip.classList.remove('show');
            setTimeout(() => {
                tooltip.textContent = isMobile() ? 
                    translations[currentLanguage].copy_tooltip_mobile : 
                    translations[currentLanguage].copy_tooltip;
            }, 200);
        }, 2000);
    } catch (err) {
        console.error('Failed to copy text: ', err);
    }
}

// Search functionality
function handleSearch(query) {
    query = query.toLowerCase();
    const results = [];

    // Search through categories and units
    for (const [category, units] of Object.entries(unitData)) {
        const categoryName = translations[currentLanguage][category] || category;
        
        if (categoryName.toLowerCase().includes(query)) {
            results.push({
                type: 'category',
                category,
                name: categoryName
            });
        }

        // Search through units
        for (const unit of Object.keys(units)) {
            if (unit.toLowerCase().includes(query)) {
                results.push({
                    type: 'unit',
                    category,
                    unit,
                    categoryName
                });
            }
        }
    }

    displaySearchResults(results);
}

function displaySearchResults(results) {
    searchResults.innerHTML = '';
    
    if (results.length === 0) {
        const noResults = document.createElement('div');
        noResults.className = 'search-result-item';
        noResults.textContent = translations[currentLanguage].no_results;
        searchResults.appendChild(noResults);
    } else {
        results.forEach(result => {
            const item = document.createElement('div');
            item.className = 'search-result-item';
            
            if (result.type === 'category') {
                item.textContent = result.name;
                item.onclick = () => {
                    categorySelect.value = result.category;
                    handleCategoryChange();
                    searchResults.classList.remove('show');
                    searchInput.value = '';
                };
            } else {
                item.textContent = `${result.unit} (${result.categoryName})`;
                item.onclick = () => {
                    categorySelect.value = result.category;
                    handleCategoryChange();
                    fromUnitSelect.value = result.unit;
                    searchResults.classList.remove('show');
                    searchInput.value = '';
                    convert();
                };
            }
            
            searchResults.appendChild(item);
        });
    }

    searchResults.classList.add('show');
}

// Favorites functionality
function toggleFavorite() {
    const currentConversion = {
        category: categorySelect.value,
        fromUnit: fromUnitSelect.value,
        toUnit: toUnitSelect.value
    };

    const existingIndex = findFavoriteIndex(currentConversion);
    
    if (existingIndex === -1) {
        favorites.push(currentConversion);
        favoriteBtn.classList.add('active');
    } else {
        favorites.splice(existingIndex, 1);
        favoriteBtn.classList.remove('active');
    }

    localStorage.setItem('favorites', JSON.stringify(favorites));
    displayFavorites();
}

function findFavoriteIndex(conversion) {
    return favorites.findIndex(fav => 
        fav.category === conversion.category &&
        fav.fromUnit === conversion.fromUnit &&
        fav.toUnit === conversion.toUnit
    );
}

function displayFavorites() {
    favoritesList.innerHTML = '';
    
    if (favorites.length > 0) {
        favoritesSection.classList.add('has-favorites');
        
        favorites.forEach((favorite, index) => {
            const item = document.createElement('div');
            item.className = 'favorite-item';
            
            const text = document.createElement('span');
            text.textContent = `${favorite.fromUnit} → ${favorite.toUnit}`;
            
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-favorite';
            removeBtn.textContent = '×';
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                favorites.splice(index, 1);
                localStorage.setItem('favorites', JSON.stringify(favorites));
                displayFavorites();
                updateFavoriteButton();
            };
            
            item.appendChild(text);
            item.appendChild(removeBtn);
            
            item.onclick = () => {
                categorySelect.value = favorite.category;
                handleCategoryChange();
                fromUnitSelect.value = favorite.fromUnit;
                toUnitSelect.value = favorite.toUnit;
                convert();
            };
            
            favoritesList.appendChild(item);
        });
    } else {
        favoritesSection.classList.remove('has-favorites');
    }
}

function updateFavoriteButton() {
    const currentConversion = {
        category: categorySelect.value,
        fromUnit: fromUnitSelect.value,
        toUnit: toUnitSelect.value
    };

    const isFavorite = findFavoriteIndex(currentConversion) !== -1;
    favoriteBtn.classList.toggle('active', isFavorite);
}

// Add calculator history functions
function addToCalculatorHistory(calculation, result) {
    calculatorHistory.unshift({
        calculation: calculation.replace(/\*/g, '×').replace(/\//g, '÷'),
        result: Number.isInteger(result) ? result : result.toFixed(8),
        timestamp: new Date().toISOString()
    });
    
    // Keep only last 10 calculations
    calculatorHistory = calculatorHistory.slice(0, 10);
    localStorage.setItem('calculatorHistory', JSON.stringify(calculatorHistory));
}

function displayCalculatorHistory() {
    const historyContainer = document.getElementById('calculatorHistory');
    if (!historyContainer) return;
    
    historyContainer.innerHTML = '';
    
    if (calculatorHistory.length === 0) {
        const emptyMessage = document.createElement('div');
        emptyMessage.className = 'history-item';
        emptyMessage.style.justifyContent = 'center';
        emptyMessage.style.color = '#666';
        emptyMessage.textContent = 'No calculations yet';
        historyContainer.appendChild(emptyMessage);
        return;
    }

    calculatorHistory.forEach((item, index) => {
        const historyItem = document.createElement('div');
        historyItem.className = 'history-item';
        
        const calcText = document.createElement('span');
        calcText.textContent = `${item.calculation} = ${item.result}`;
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'history-item-buttons';

        const reloadButton = document.createElement('button');
        reloadButton.className = 'reload-btn';
        reloadButton.textContent = '↺';
        reloadButton.title = 'Reload calculation';
        reloadButton.onclick = () => {
            currentCalculation = item.result.toString();
            calcDisplay.textContent = item.result;
            shouldResetDisplay = true;
        };
        
        const deleteButton = document.createElement('button');
        deleteButton.className = 'delete-btn';
        deleteButton.textContent = '×';
        deleteButton.title = 'Delete calculation';
        deleteButton.onclick = () => {
            calculatorHistory.splice(index, 1);
            localStorage.setItem('calculatorHistory', JSON.stringify(calculatorHistory));
            displayCalculatorHistory();
        };
        
        buttonsContainer.appendChild(reloadButton);
        buttonsContainer.appendChild(deleteButton);
        
        historyItem.appendChild(calcText);
        historyItem.appendChild(buttonsContainer);
        historyContainer.appendChild(historyItem);
    });
}

// Add physics history functions
function addToPhysicsHistory(type, inputs, results) {
    physicsHistory[type].unshift({
        inputs,
        results,
        timestamp: new Date().toISOString()
    });
    
    // Keep only last 10 calculations per type
    physicsHistory[type] = physicsHistory[type].slice(0, 10);
    localStorage.setItem('physicsHistory', JSON.stringify(physicsHistory));
}

function displayPhysicsHistory(type) {
    const historyContainer = document.getElementById(`${type}History`);
    if (!historyContainer) return;
    
    historyContainer.innerHTML = '';
    
    if (physicsHistory[type].length === 0) {
        const emptyMessage = document.createElement('div');
        emptyMessage.className = 'history-item';
        emptyMessage.style.justifyContent = 'center';
        emptyMessage.style.color = '#666';
        emptyMessage.textContent = `No ${type} calculations yet`;
        historyContainer.appendChild(emptyMessage);
        return;
    }

    physicsHistory[type].forEach((item, index) => {
        const historyItem = document.createElement('div');
        historyItem.className = 'history-item';
        
        const calcText = document.createElement('span');
        calcText.textContent = item.results;
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'history-item-buttons';

        const reloadButton = document.createElement('button');
        reloadButton.className = 'reload-btn';
        reloadButton.textContent = '↺';
        reloadButton.title = 'Reload calculation';
        reloadButton.onclick = () => {
            // Restore input values
            Object.entries(item.inputs).forEach(([key, value]) => {
                const input = document.getElementById(key);
                if (input) input.value = value;
            });
            
            // Trigger recalculation
            switch(type) {
                case 'freefall':
                    handleFreefallCalculation();
                    break;
                case 'suvat':
                    handleSuvatCalculation();
                    break;
                case 'projectile':
                    handleProjectileCalculation();
                    break;
                case 'forces':
                    handleForcesCalculation();
                    break;
            }
        };
        
        const deleteButton = document.createElement('button');
        deleteButton.className = 'delete-btn';
        deleteButton.textContent = '×';
        deleteButton.title = 'Delete calculation';
        deleteButton.onclick = () => {
            physicsHistory[type].splice(index, 1);
            localStorage.setItem('physicsHistory', JSON.stringify(physicsHistory));
            displayPhysicsHistory(type);
        };
        
        buttonsContainer.appendChild(reloadButton);
        buttonsContainer.appendChild(deleteButton);
        
        historyItem.appendChild(calcText);
        historyItem.appendChild(buttonsContainer);
        historyContainer.appendChild(historyItem);
    });
} 
